name: Unit Test Coverage PR Comment

on:
  pull_request:
    types: [opened, synchronize]

permissions:
  pull-requests: write
  contents: read

jobs:
  coverage-comment:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Post coverage comment
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const path = 'unit-coverage/coverage-summary.json';

            if (!fs.existsSync(path)) {
              core.warning('No unit-coverage/coverage-summary.json found. Run `npm run test:unit:coverage` locally and commit the summary.');
              return;
            }

            const summary = JSON.parse(fs.readFileSync(path, 'utf8'));
            const total = summary.total || {};
            const metrics = ['statements', 'branches', 'functions', 'lines'];

            const pctBar = (pct) => {
              if (pct === '' || pct === undefined) return '\u2014';
              const num = Number(pct);
              let icon = '\ud83d\udd34';
              if (num >= 80) icon = '\ud83d\udfe2';
              else if (num >= 50) icon = '\ud83d\udfe1';
              return `${icon} ${num.toFixed(1)}%`;
            };

            let body = `## \ud83e\uddea Unit Test Coverage Report\n\n`;
            body += `| Metric | Covered | Total | Coverage |\n`;
            body += `|--------|---------|-------|----------|\n`;

            for (const m of metrics) {
              if (total[m]) {
                const label = m.charAt(0).toUpperCase() + m.slice(1);
                body += `| **${label}** | ${total[m].covered} | ${total[m].total} | ${pctBar(total[m].pct)} |\n`;
              }
            }

            // Clean absolute file paths to relative src/ paths
            const cleanName = (name) => {
              const match = name.match(/\/src\/(.+)$/);
              if (match) return `src/${match[1]}`;
              return name;
            };

            const files = Object.entries(summary)
              .filter(([key]) => key !== 'total')
              .map(([file, data]) => ({
                file: cleanName(file),
                statements: data.statements?.pct ?? '',
                branches: data.branches?.pct ?? '',
                functions: data.functions?.pct ?? '',
                lines: data.lines?.pct ?? '',
              }))
              .filter(f => {
                // Only show files with some coverage (skip 0% files to keep comment readable)
                return [f.statements, f.branches, f.functions, f.lines].some(v => v !== '' && Number(v) > 0);
              })
              .sort((a, b) => {
                const aMin = Math.min(...[a.statements, a.branches, a.functions, a.lines].filter(v => v !== ''));
                const bMin = Math.min(...[b.statements, b.branches, b.functions, b.lines].filter(v => v !== ''));
                return bMin - aMin;
              });

            if (files.length > 0) {
              body += `\n<details>\n<summary>\ud83d\udcc1 Covered files (${files.length} files with coverage)</summary>\n\n`;
              body += `| File | Statements | Branches | Functions | Lines |\n`;
              body += `|------|-----------|----------|-----------|-------|\n`;
              for (const f of files) {
                body += `| \`${f.file}\` | ${pctBar(f.statements)} | ${pctBar(f.branches)} | ${pctBar(f.functions)} | ${pctBar(f.lines)} |\n`;
              }
              body += `\n</details>\n`;
            }

            body += `\n---\n*Coverage collected locally via Vitest + V8. Run \`npm run test:unit:coverage\` to update.*`;

            // Find existing bot comment
            const comments = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });
            const existing = comments.data.find(c =>
              c.user.type === 'Bot' && c.body.includes('Unit Test Coverage Report')
            );

            if (existing) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: existing.id,
                body,
              });
              core.info(`Updated existing comment #${existing.id}`);
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body,
              });
              core.info('Created new coverage comment');
            }
